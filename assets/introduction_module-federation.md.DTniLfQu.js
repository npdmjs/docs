import{_ as s,c as i,o as a,a1 as e}from"./chunks/framework.DZ20Tprd.js";const m=JSON.parse('{"title":"Module Federation","description":"","frontmatter":{"outline":[2,3]},"headers":[],"relativePath":"introduction/module-federation.md","filePath":"introduction/module-federation.md"}'),n={name:"introduction/module-federation.md"},t=e(`<h1 id="module-federation" tabindex="-1">Module Federation <a class="header-anchor" href="#module-federation" aria-label="Permalink to &quot;Module Federation&quot;">​</a></h1><h2 id="preface" tabindex="-1">Preface <a class="header-anchor" href="#preface" aria-label="Permalink to &quot;Preface&quot;">​</a></h2><p>Since NPDM server only serves static files from the NPM packages, to use remote components as microfrontends, we need some other technology. The-state-of-art solution is the <a href="https://module-federation.io/" target="_blank" rel="noreferrer">Module Federation</a>.</p><p>This article describes a proof-of-concept of the approach which can be used to implement versioned microfrontends with deployment through the NPDM server. To integrate NPDM server with the Module Federation, a few abstractions were introduced.</p><p>To check example implementation, refer to the <a href="./example.html">Example</a> article.</p><h2 id="abstractions" tabindex="-1">Abstractions <a class="header-anchor" href="#abstractions" aria-label="Permalink to &quot;Abstractions&quot;">​</a></h2><h3 id="package-specification" tabindex="-1">Package Specification <a class="header-anchor" href="#package-specification" aria-label="Permalink to &quot;Package Specification&quot;">​</a></h3><p>Package specification describes a versioned remote component (microfrontend). It should contain information, in which NPM package the remote module should be found, and its default version, which has to be changed later in runtime. Another important part of the package specification is the field <code>remoteEntryRelativePath</code> which defines the path to the entry file, relative to the root of the NPM package. Package specification has type <a href="./../api-reference/npdm-module-federation.html#dynamicpackagespec">DynamicPackageSpec</a>.</p><p>Here is an example of the package specification:</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { DynamicPackageSpec } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@npdm/module-federation&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> packageSpec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DynamicPackageSpec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // where the remote component is placed:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  packageName: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;npdmjs-react-example&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // default package version, which is changed in runtime:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  packageVersion: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1.0.0&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // path to the Module Federation entry file in the package:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  remoteEntryRelativePath: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/npdm/entry.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="dynamic-module" tabindex="-1">Dynamic Module <a class="header-anchor" href="#dynamic-module" aria-label="Permalink to &quot;Dynamic Module&quot;">​</a></h3><p>If package specification defines the remote, the dynamic module defines and describes particular module which is <a href="https://module-federation.io/configure/exposes.html" target="_blank" rel="noreferrer">exposed</a> in this remote.</p><p>Because we can use dynamic modules from the different package versions, each module should include its package specification. First reason why dynamic module exists as an object an abstraction is that we should define exposed component as the part of the versioned package. The second reason is that dynamic module plays the role of an interface which defines rules of how this component should be used. Here is the example of the dynamic module:</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { packageSpec } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./packageSpec.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { FC } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { DynamicModule } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@npdm/module-federation&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WonderfulButtonProps</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  label</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// our React component type</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WonderfulButtonType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WonderfulButtonProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wonderfulButtonModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DynamicModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // this will be module, which contains default component</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WonderfulButtonType</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // in the &#39;exposes&#39; field in ModuleFederationPlugin:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // &#39;./Button&#39;: &#39;./src/components/WonderfulButton.tsx&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  exposedPath: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/Button&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // we use some exiting package specification</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  packageSpec,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="recommended-rules" tabindex="-1">Recommended Rules <a class="header-anchor" href="#recommended-rules" aria-label="Permalink to &quot;Recommended Rules&quot;">​</a></h2><p>Both package and dynamic module specifications supposed to define interfaces which can allow safe usage of the remote modules in the host application.</p><p>In the proposed approach we put all the specifications into the package first of all for the sake of the semantic versioning. The logic behind it is that when interface of the component changes, we have to update our consumer applications accordingly anyway. Such an approach can lose in terms of flexibility comparing to the <a href="https://module-federation.io/guide/basic/type-prompt.html" target="_blank" rel="noreferrer">Module Federation remote types</a>, but at the same time we can guarantee during local testing that interfaces will be aligned with the remote modules.</p><p>The next rules can be recommended to achieve maximal stability:</p><ol><li><p><strong>Package specification should not be changed during package lifetime, except if only default <code>packageVersion</code></strong>. To ensure safe switching between different modules we should make sure that the entry point and remote name stays the same.</p></li><li><p><strong>Each breaking change in the dynamic module specification should be published with the new major version.</strong> In the future versions of <code>@npdm/module-federation</code> we may add validation logic to make sure that version of remote module which was set dynamically during runtime aligns with the major version of the package used in the application.</p></li><li><p><strong>Each change in the dynamic module specification which is not breaking, should be published with the new minor version of the package</strong>. In case if in your application you want to use new features from the remote module, you should upgrade package version to get new interfaces.</p></li></ol>`,19),h=[t];function l(p,o,r,k,d,c){return a(),i("div",null,h)}const u=s(n,[["render",l]]);export{m as __pageData,u as default};
